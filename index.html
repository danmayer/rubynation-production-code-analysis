<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=1024, user-scalable=no">

  <title>Production Code Analysis</title>

  <!-- Required stylesheet -->
  <link rel="stylesheet" media="screen" href="core/deck.core.css">

  <!-- Extension CSS files go here. Remove or add as needed. -->
  <link rel="stylesheet" media="screen" href="extensions/goto/deck.goto.css">
  <link rel="stylesheet" media="screen" href="extensions/menu/deck.menu.css">
  <link rel="stylesheet" media="screen" href="extensions/status/deck.status.css">
  <link rel="stylesheet" media="screen" href="extensions/scale/deck.scale.css">

  <link rel="stylesheet" href="highlight/styles/github.css">
  <script src="highlight/highlight.pack.js"></script>

  <!-- Style theme. More available in /themes/style/ or create your own. -->
  <link rel="stylesheet" media="screen" href="themes/style/ls.css">

  <!-- Transition theme. More available in /themes/transition/ or create your own. -->
  <link rel="stylesheet" media="screen" href="themes/transition/horizontal-slide.css">

  <!-- Basic black and white print styles -->
  <link rel="stylesheet" media="print" href="core/print.css">

  <!-- Required Modernizr file -->
  <script src="modernizr.custom.js"></script>
</head>
<body>
  <div class="deck-container">

    <div class="header">
      &nbsp;
    </div>
    <!-- Begin slides. Just make elements with a class of slide. -->

    <section class="slide">
      <h1>Production Code Analysis</h1>
      <p>
        <ul>
	  <li>
	    Dan Mayer (<a href="http://livingsocial.com">LivingSocial</a>)
	    <ul>
	      <li><a href="http://mayerdan.com">http://mayerdan.com</a></li>
	      <li><a href="http://github.com/danmayer">github: @danmayer</a></li>
	      <li><a href="http://twitter.com/danmayer">twitter: @danmayer</a></li>
	    </ul>
	  </li>
        </ul>
      </p>
    </section>

    <section class="slide">
      <h2>Spaghetti Code</h2>
      <table style="text-align:center; width='100%'"><tr><td>
	      <img src="./images/spagetti-code-bowl.png" />
	</td><td>
	      <img src="./images/spaghetti-code-spaghetti-fork.jpg" />
      </td></tr></table>
      
      <div class="slide-notes">
	We have all seen spaghetti code. It is hard to understand and
      follow all the possible paths. Difficult to change, but as
      projects grow and change seems impossible to entirely
      avoid. Untangling it is hard, first I want to briefly and quickly explain
      how a project can reach a point where there is over 200KLOC that
      can be removed. Then I can explain some processes to help find
      and remove unnessary complexity.
	spaghetti-code-bowl:
      http://overloadstudios.blogspot.com/2010/11/debugging-spaghetti-code.html
	spaghetti-fork: http://www.troll.me/2011/12/17/spaghetti-fork/spaghetti-code-spaghetti-fork/
      </div>
    </section>

    <section class="slide">
      <h2>MonoRail</h2>
      <ul>
        <li class="slide">
          <h3>Pre Existing</h3>
          <img src="./images/monorail.jpg" />
        </li>
        <li class="slide">
          <h3>Consumer</h3>
          <img src="./images/monorail2.jpg" />
        </li>
	<li class="slide">
          <h3>CRMS</h3>
          <img src="./images/monorail3.jpg" />
        </li>
	<li class="slide">
          <h3>CMS</h3>
          <img src="./images/monorail4.jpg" />
        </li>
	<li class="slide">
          <h3>Admin</h3>
          <img src="./images/monorail5.jpg" />
        </li>
	<li class="slide">
          <h3>Next?</h3>
          <img src="./images/monorail6.jpg" />
        </li>
      </ul>
      <div class="slide-notes">
	Yes, a large years old project. We have a Monorail! A bit of
      history. The application began as a fork of an existing project
      to quickly validate an idea. That grew into a consumer business. That
      business app was forked to seperate out some Costomer
      Relationship Manament functions. Later the consumer business
      app was forked again to split out the content management
      functions, and finally again spliting out admin
      functionality. This means all that apps share some of the same
      code, but after each split they have less responsibility. Which
      code is needed for the smaller slice of responsibilities, what
      can be removed from the parent app? Looking production runtime
      can tell you. 
	images: simpsons
      </div>
    </section>

    <section class="slide">
      <h2>How Dead Code Sticks Around</h2>
      <p>
        <ul>
	  <li>
	  Large teams aren't good at communicating what is no
      longer needed
	  </li>
      	  <li>AB tests, never removing a loser</li>
	  <li>One offs that are irrelevant over time</li>
	  <li>Deprecation of old endpoints takes time</li>
	  <li>Refactoring leaves dead code paths behind</li>
      	  <li>A dev trying to be 'safe' & creating new methods
      opposed to altering existing methods with multiple callers</li>
	  <li>There are tests, but it is never used in production</li>
          <li>etc...</li>
	</ul>
      </p>
      <div class="slide-notes">
	Beyond Monorails, dead code can slip into a system many
      ways. I am not really going into all the details, but suffice to
      say. Every system I have worked on grows and at some point has
      unnessary code tucked away into the corners at some
      point. Features that don't quite justify their UI complexity,
      pivoting away from some direction... Whatever reason there is,
      code sits around.
      </div>
    </section>
	
    <section class="slide">
      <h2>All code is bad</h2>
      <img src="./images/code-horror.gif" />
      <blockquote cite="http://mashable.com/2014/04/30/programming-sucks/">
        <p>
	  Also, the bridge was designed as a suspension bridge, but nobody actually knew how to build a suspension bridge, so they got halfway through it and then just added extra support columns to keep the thing standing
	</p>
        <p><cite>
	<a href="http://mashable.com/2014/04/30/programming-sucks/">
	Peter Welch (Programming Still Sucks)
	</a>
	</cite></p>
      </blockquote>
      <div class="slide-notes">
	Their is a pretty hilarious article how "programming still
      sucks" by Peter Welch. In it he makes the analogy of a team
      building a bridge, not knowing what they are doing building half
      suspension and half support.
      </div>
    </section>

    <section class="slide">
      <h2>
	Less Code Is Better
      </h2>
      <ul>
	  <li>is easier to reason about</li>
	  <li>is easier to upgrade (Rails, Ruby, and Gem versions)</li>
	  <li>is easier to refactor</li>
	  <li>is easier to adapt to new requirements</li>
      </ul>
      <div class="slide-notes">
	Obviously, a bit jokingly that article states that "all code
      is bad". Obviously if the code is doing work it has some value,
      but I don't think I have to spend time on why having less code
      and simpler systems is better.
      </div>
    </section>

    <section class="slide">
      <h2>
	Solution: Clean Up Dead Code
      </h2>
      <ul>
	  <li>If "All Code is Bad"</li>
	  <li>Less Code is Better</li>
	  <li>Keep Only the Code Needed, No More</li>
      </ul>
      <div class="slide-notes">
	We can make our projects better by only working on the code we
      need. The code that is actively adding value to our
      business.
      </div>
    </section>

    <section class="slide">
      <h2>All code is bad</h2>
      <img src="./images/code-horror.gif" />
      <blockquote cite="http://mashable.com/2014/04/30/programming-sucks/">
        <p>
	  They left the suspension cables because they're still sort
      of holding up parts of the bridge. Nobody knows which parts, but
      everybody's pretty sure they're important parts.
	</p>
        <p><cite>
	<a href="http://mashable.com/2014/04/30/programming-sucks/">
	Peter Welch (Programming Still Sucks)
	</a>
	</cite></p>
      </blockquote>
      <div class="slide-notes">
	In the article the bridge analogy continues, explaining why the
      team left the suspension cables up after switching to a support
      column bridge.
      </div>
    </section>

    <section class="slide">
      <h2>How to know: Production Code Analysis</h2>
      <blockquote cite="http://mashable.com/2014/04/30/programming-sucks/">
        <p>
	  Nobody knows which parts, but everybody's pretty sure they're important parts.
	</p>
        <p><cite>
	<a href="http://mashable.com/2014/04/30/programming-sucks/">
	Peter Welch (Programming Still Sucks)
	</a>
	</cite></p>
      </blockquote>
      <div class="slide-notes">
	We don't have to settle for guessing, we can solve this
      problem... With you know "science"
      </div>
    </section>

    <section class="slide">
      <h2>Analyzing Production Code</h2>
      <p>
        <ul>
      	  <li>Use <a href="http://newrelic.com">NewRelic</a>,
	  <a href="https://www.skylight.io/">skylight.io</a>,
	  or <a href="http://info.appneta.com/watrial.html?product=traceview">Appneta Traceview (formerly Tracelytics)</a></li>
	  <li>Custom Stats Instrumentation</li>
	  <li>Use Logs</li>
	  <li>Production Code Coverage</li>
        </ul>
      </p>
      <div class="slide-notes">
	I am going to go through some examples of processes we have
      used to find unused code. From very simple methods, to more
      complicated processes.
      </div>
    </section>

    <section class="slide">
	<h2>Street Cred</h2>
	<img src="./images/deals_loc.png" />
	<p>(grown up marketing speak: "steet cred" => "social
	proof")</p>
      <div class="slide-notes">
	Just to show that this isn't some idea, these are processes we
	have been able to put into practice. Here is my history on one
	of our Monorails apps. I am pretty proud to have removed
	nearly 2 lines of code for every one added, while delivery
	additional functionality and faster performance.
      </div>
    </section>

    <section class="slide">
	<h2>Team Effort</h2>
	<pre>[~/projects/deals]git log --numstat --pretty="%H" --author="dan.mayer" --since="2 years ago" app | awk 'NF==3 {plus+=$1; minus+=$2} END {printf("+%d, -%d\n", plus, minus)}'
+20973, -47034</pre>
	<pre>[~/projects/deals] git log --numstat --pretty="%H" --since="2 years ago" app | awk 'NF==3 {plus+=$1; minus+=$2} END {printf("+%d, -%d\n", plus, minus)}'
+197326, -215514</pre>
        <div class="slide-notes">
	  Also, wanted to point out getting code bases into shape. Is
	really a team effort. As a team we celebrate our code
	improvements. Cheers particularly good commits, faster tests,
	code removals. Linking to little victories in campfire all the
	way. One of the split out Monorails previously mentioned went
	from a total LOC of 160K (including html,js, css assets) to
	only 15K becoming a relatively tame and simple app.
	</div>
    </section>
	
    <section class="slide">
      <h2>Using 3rd Party tool (NewRelic)</h2>
      <p>Easiest way, look transactions over last 7 days: (note won't
      help with specific formats or never hit endpoints)</p>
      <img src="./images/NR_usage.png" />
      <div class="slide-notes">
	One of the easiest ways to gain insight into what code is
      being used in production is checking with any of the 3rd part
      performance monitoring tools. In this case NewRelic but I am
      sure Skylight.io and Traceview can get you the same data. In
      this view you can sort transactions broken down by controller
      route by usage. Anything with 1 view likely isn't pulling its
      weight. This view also doesn't show you what received 0 requests.
      </div>
    </section>

    <section class="slide">
      <h2>Using 3rd Party tool (NewRelic)</h2>
      <p>LS made a gem to help,
        <a href="https://github.com/livingsocial/newrelic_route_check">newrelic_route_check</a>
      compare NR reports to Rails routes.</br>
	download the `controller_summary.csv`</p>
      <img src="./images/NR_download.png" />
      <p>run `bundle exec rake newrelic:compare_with_routes`</p>
      <pre>found 335 uniq new relic controller action hits
found 562 uniq Rails routes controller action pairs
exists in new relic, but not in routes: 0
never accessed in new relic stats: ***
Pipeline::DealsController#show
Pipeline::EmailTemplatesController#show
SubscribeButtonController#dropdown_for_deal
...
AuthorizationRulesController#graph
AuthorizationRulesController#change</pre>
      <div class="slide-notes">
        I created a gem to make this easy to check. You can download
      the CSV of NR transactions and it can compare it to your Rails
      routes. Finding any routes you have which are never hit. Running
      this on old production apps always seems to find some long
      forgotten routes.
      </div>
    </section>

    <section class="slide">
      <h2>Stats Instrumentation</h2>
      <p>
        <ul>
	  <li>No NewRelic: No Problem</li>
      	  <li>Background Events Executed: All events being triggered?</li>
	  <li>Emails Sent: Are you still sending all your mailers?</li>
	  <li>Views Rendered: partials, templates, and layouts</li>
	  <li>One Off Trackers: usage of code
      branches & other hard to verify code</li>
	  <li>Production Performance Comparisons: What's faster on
      production data</li>
	  <li>Translations Usage: How many translation keys are you
      loading in memory & never using</li>
        </ul>
      </p>
      <div class="slide-notes">
        Custom Stats instrumentation is very flexible. We are going to
      look at a number of techniques to gain insight into what your
      application is actually doing in production. I wanted to give a
      shout out to <a href="http://codeascraft.com/category/engineering/">Etsy</a> here, as we rely heavily on StatsD, and they
      have shared in great detail how they also use metrics to gain
      all sorts of code and business insights.
      </div>
    </section>

    <section class="slide">
      <h2>Stats Instrumentation: No NewRelic, No Problem</h2>
      <pre>yo code goes here for both controller#action counts and
      render#time counts</pre>
    </section>

    <section class="slide">
      <h2>Stats Instrumentation: Background Events Executed</h2>
      <pre><code># Example for Resque background jobs
STATSD = Statsd.new(host, port).tap{|sd| sd.namespace = 'app_name'}

def before_perform(*args)
  STATSD.increment "resque.processed.#{get_event_name}"
end

def after_perform(*args)
  STATSD.increment "resque.completed.#{get_event_name}"
end</code></pre>
      <div class="slide-notes">
	If you run a sizable Rails app you likely run background
  jobs. Some jobs will come and go over time. It is pretty easy to
  remove code that queues a job, while leaving around the job code and
  related methods. It is easy to instrument how often something is
  processed, completed, and if you like performance around that and
  success/failures on completion. This is a simple example assuming
  Resque, but is pretty similar for all queueing frameworks.
      </div>
    </section>

    <section class="slide">
      <h2>Stats Instrumentation: Emails Sent</h2>
      <pre><code># Example for ActionMailer
STATSD = Statsd.new(host, port).tap{|sd| sd.namespace = 'app_name'}

class BaseMailer < ActionMailer::Base
  def initialize(method_name=nil, *parameters)
    STATSD.increment "mailers.base_mailer.#{method_name}" if method_name
    #...
    super(method_name, *parameters)
  end
end</code></pre>
     <div class="slide-notes">
       Mailers like background jobs and come and go. Stating every
  mailer as it is sent lets you know when a mailer is no longer needed
  anymore. Or perhaps which mailers you should spend more time
  improving based on the send volume. Simple example of hooking into
  action mailer to stat every mailer we send.
      </div>
    </section>
	
    <section class="slide">
      <h2>Stats Instrumentation: Views Rendered</h2>
      <pre><code>ActiveSupport::Notifications.subscribe /render_partial.action_view|render_template.action_view/ do |name, start, finish, id, payload| 
  RenderTracker.track_template(name, start, finish, id, payload) unless name.include?('!') 
end

class RenderTracker
  def self.track_template(name, start, finish, id, payload)
    if file = payload[:identifier]
      Statsd.increment "views.#{file}"
    end
    if layout = payload[:layout]
      Rails.logger.info "[RenderTracker] layout: #{layout}"
    end
  end
end</code></pre>
     <div class="slide-notes">
       The view layer more than anywhere else can get quickly messy
  and hard to follow. Partials inside layouts, inside partials, and
  ajax... Oh My... A new view gets tested or moved and people aren't
  sure if the partial is used anywhere else. Well with activesupport
  notifications it is easy to stats every view file as it is
  rendered. Again beyond finding unused view code (and the related
  helpers), you get a nice picture of what your most important view
  componnets actually are.
     </div>
    </section>

    <section class="slide">
      <h2>Stats Instrumentation: Views Rendered</h2>
      <p>We made a gem for that and some helpers: <a href="https://github.com/livingsocial/flatfoot">Flatfoot</a>
      <pre><code>FLATFOOT = Flatfoot::Tracker.new(Redis.new)

ActiveSupport::Notifications.subscribe /render_partial.action_view|render_template.action_view/ do |name, start, finish, id, payload|
  FLATFOOT.track_views(name, start, finish, id, payload) unless name.include?('!') 
end

FLATFOOT.used_views
=> ["app/views/home/index.html.erb",...

FLATFOOT.unused_views
=> ["app/views/something/_old_partial.html.erb",...</code></pre>
      <div class="slide-notes">
	The view tracking pattern is simple and we wanted to reuse it
	a few places. So we have a nice little gem to quickly hook it
	up into Rails apps. It provides some helpers to output unused
	views by comparing the view renderings with the files you
	actually have on disk. Making it super simple to do some view
	layer cleanup.
      </div>
    </section>

    <section class="slide">
      <h2>Stats Instrumentation: One Off Trackers</h2>
      <pre><code># Example Tracking a code path
class HomeController < ApplicationController
  def show
    if request.xhr?
       #some weird logic
       STATSD.increment "deprecated.home_controller.show.xhr"
     end
    respond_to do |format|
        format.html { STATSD.increment "deprecated.home.show.html" }
        format.json { STATSD.increment "deprecated.home.show.json" }
        format.mobile { STATSD.increment "deprecated.home.show.mobile" }
    end
  end
end</code></pre>
    </section>

    <section class="slide">
      <h2>Stats Instrumentation: Production Performance Comparisons</h2>
      <p>shout out to <a href="https://twitter.com/ubermajestix">@ubermajestix (Tyler Montgomery)</a> for showing me the timing trick</a>
      <pre><code>STATSD = Statsd.new(host, port).tap{|sd| sd.namespace = 'app_name'}

def example_html_stripping_method
  strip_method = rand(2)&1 == 0 ? 'nokogiri' : 'strip_tags'
  desc = STATSD.time("application_helper.example_html_stripping_method.#{strip_method}") do
    if strip_method == 'strip_tags'
      strip_tags(desc_raw).gsub(/^\s+/,'').gsub(/\s+$/,'')
    else
      Nokogiri::HTML.parse(desc_raw).text.strip
    end
  end
  #...
end</code></pre>
    </section>

    <section class="slide">
      <h2>Stats Instrumentation: Translations Usage</h2>
      <p>We made a gem for that <a href="https://twitter.com/the_chrismo">@Chrismo (Chris Morris)</a> built: <a href="https://github.com/livingsocial/humperdink">Humperdink</a>
      <pre><code>class KeyTracker
  def initialize(redis, key)
    redis_set = Humperdink::RedisDirtySet.new(:redis => redis, :key => key, :max_dirty_items => 9)
    @tracker = Humperdink::Tracker.new(redis_set, :enabled => true)
  end

  def on_translate(locale, key, options = {})
    begin
      if @tracker.tracker_enabled
        requested_key = normalize_requested_key(key, options)
        @tracker.track(requested_key)
      end
    rescue => e
      @tracker.shutdown(e)
    end
  end
...</code></pre>
    </section>

    <section class="slide">
      <h2>Production Code Coverage: Coverband</h2>
      <p>
        <ul>
	  <li>Based on `set_trace_func`</li>
      	  <li>It would be better to be based on `Coverage` but there is a bug in Ruby</li>
	  <li>(Looking for C help, so I can try to patch Ruby, anyone
      got those skills?)</li>
	  <li>Performance hit reduced by sampling</li>
	  <li>
	    <a href="https://github.com/danmayer/coverband">github.com/danmayer/coverband</a>
	  </li>
          <li>Example Output:
	    <a href="./examples/coverage/index.html" target="blank">churn-site coverage</a>
	  </li>
        </ul>
      </p>
    </section>

   <section class="slide">
      <h2>Production Code Coverage: Coverband</h2>
      <pre><code>baseline = Coverband.parse_baseline
Coverband.configure do |config|
  config.root              = Dir.pwd
  config.redis   = Redis.new(:host => 'redis.host.com')
  config.coverage_baseline = baseline
  config.root_paths        = ['/app/']
  config.ignore            = ['vendor']
  config.startup_delay = Rails.env.production? ? 15 : 1
  config.percentage    = Rails.env.production? ? 20.0 : 90.0
  config.stats         = Statsd.new('stat.my.com', 25)
  config.verbose       = Rails.env.production? ? false: true
end</code></pre>
    </section>

    <section class="slide">
      <h2>Production Code Coverage: Coverband</h2>
      <pre><code>#configure rake
require 'coverband'
Coverband.configure
require 'coverband/tasks'

#setup middleware in `config.ru`
require File.dirname(__FILE__) + '/config/environment'
require 'coverband'
Coverband.configure

use Coverband::Middleware
run ActionController::Dispatcher.new</code></pre>
    </section>

    <section class="slide">
      <h2>Logs</h2>
      <p>
        <ul>
	  <li>Logs need to be searchable, real time is best.
	  (ElasticSearch/Kibana, Splunk, Hadoop)</li>
	  <li>All your logs should be in one place 
	  (cron, nginx access/error, background jobs, rails logs)</li>
      	  <li>If you have multiple apps that communicate they should
      be in the same system.</li>
          <li>Try to standardize log format & some keys / variables
      across systems</li>
        </ul>
      </p>
    </section>

    <section class="slide">
      <h2>Logs: Better with Imprint</h2>
      <p>Another LS gem
	<a href="https://github.com/livingsocial/imprint">Imprint</a>
	 <ul>
	   <li>Request tracing in logs:<br/>
	    All Rails.logger calls during a request tagged with a trace_id</li>
	   <li>Exceptions include trace_id so you can fetch all logs
      related to a request that caused an exception</li>
           <li>Background Jobs failures include the trace_id to find
      the request that queued the job</li>
           <li>Cross app tracing, have client gems pass a header, and
      back end APIs will include the same trace_id as the initial
      front end request</li>
	 </ul>
      </p>
	
    </section>

    <section class="slide ls">
      <h1>Thanks</h1>
      <p>
        <ul>
	  <li>
	    Dan Mayer
	    <ul>
	      <li><a href="http://mayerdan.com">http://mayerdan.com</a></li>
	      <li><a href="http://github.com/danmayer">github: @danmayer</a></li>
	      <li><a href="http://twitter.com/danmayer">twitter: @danmayer</a></li>
	    </ul>
	  </li>
	  <li><a href="http://livingsocial.com">LivingSocial</a>
      (We're hiring)<br/>
	  Thanks for sending me to various conferences!
	  </li>
        </ul>
      </p>
    </section>

    <!-- End slides. -->

    <!-- Begin extension snippets. Add or remove as needed. -->

    <!-- deck.status snippet -->
    <p class="deck-status" aria-role="status">
      <span class="deck-status-current"></span>
      /
      <span class="deck-status-total"></span>
    </p>

    <!-- deck.goto snippet -->
    <form action="." method="get" class="goto-form">
      <label for="goto-slide">Go to slide:</label>
      <input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
      <datalist id="goto-datalist"></datalist>
      <input type="submit" value="Go">
    </form>

    <!-- End extension snippets. -->
  </div>

<!-- Required JS files. -->
<script src="jquery.min.js"></script>
<script src="core/deck.core.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="extensions/menu/deck.menu.js"></script>
<script src="extensions/goto/deck.goto.js"></script>
<script src="extensions/status/deck.status.js"></script>
<script src="extensions/navigation/deck.navigation.js"></script>
<script src="extensions/scale/deck.scale.js"></script>

<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
  $(function() {
    $.deck('.slide');
  });
</script>
<script>hljs.initHighlightingOnLoad();</script>
</body>
</html>
