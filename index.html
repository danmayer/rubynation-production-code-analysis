<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
  <meta name="viewport" content="width=1024, user-scalable=no">

  <title>Production Code Analysis</title>

  <!-- Required stylesheet -->
  <link rel="stylesheet" media="screen" href="core/deck.core.css">

  <!-- Extension CSS files go here. Remove or add as needed. -->
  <link rel="stylesheet" media="screen" href="extensions/goto/deck.goto.css">
  <link rel="stylesheet" media="screen" href="extensions/menu/deck.menu.css">
  <link rel="stylesheet" media="screen" href="extensions/status/deck.status.css">
  <link rel="stylesheet" media="screen" href="extensions/scale/deck.scale.css">

  <link rel="stylesheet" href="highlight/styles/github.css">
  <script src="highlight/highlight.pack.js"></script>

  <!-- Style theme. More available in /themes/style/ or create your own. -->
  <link rel="stylesheet" media="screen" href="themes/style/ls.css">

  <!-- Transition theme. More available in /themes/transition/ or create your own. -->
  <link rel="stylesheet" media="screen" href="themes/transition/horizontal-slide.css">

  <!-- Basic black and white print styles -->
  <link rel="stylesheet" media="print" href="core/print.css">

  <!-- Required Modernizr file -->
  <script src="modernizr.custom.js"></script>
</head>
<body>
  <div class="deck-container">

    <div class="header">
      <img src="images/livingsocial-logo-nav.png" />
    </div>
    <!-- Begin slides. Just make elements with a class of slide. -->

    <section class="slide">
      <h1>Production Code Analysis</h1>
      <p>
        <ul>
	  <li>
	    <a href="http://www.mayerdan.com">Dan Mayer</a> (<a href="http://livingsocial.com">LivingSocial</a>)
	    <ul>
	      <li>slides: <a href="http://www.mayerdan.com/rubynation-production-code-analysis/">mayerdan.com/rubynation-production-code-analysis/</a></li>
	      <li><a href="http://twitter.com/danmayer">twitter: @danmayer</a></li>
	    </ul>
	  </li>
        </ul>
      </p>
      <div class="slide-notes">
	Hello. I am Dan Mayer from LivingSocial
	<br/><br/>
	I am here to talk about production code analysis, Tales of
      Deleting 200K+ LOC.
	<br/><br/>
	As the talk title indicates I am focusing on finding unused
      code using analysis.
      </div>
    </section>

    <section class="slide">
      <h2>Spaghetti Code</h2>
      <table style="margin: 0px auto;"><tr><td>
	  <img src="./images/spagetti-code-bowl.png" />
	  <span class="img-src">-
	    <a href="http://overloadstudios.blogspot.com/2010/11/debugging-spaghetti-code.html">overload studios</a>
	  </span>
	</td><td>
	  <img src="./images/spaghetti-code-spaghetti-fork.jpg" />
	  <span class="img-src">-
	    <a href="http://www.troll.me/2011/12/17/spaghetti-fork/spaghetti-code-spaghetti-fork/">troll.me</a>
	  </span>
      </td></tr></table>
      <div class="slide-notes">
	spaghetti code!
	<br/><br/>
	We have all seen spaghetti code.
	It is hard to understand<br/>
	Hard to follow all the code paths.<br/>
	It is difficult to change and maintain.
        <br/><br/>
	As projects grow and age it is very difficult to entirely
      avoid.
	<br/>
	Untangling it is hard but runtime analysis can help.
	<br/><br/>
      First I want to briefly explain
      how a project can reach a point where there is over 200KLOC that
      can be removed.
	<br/><br/>
	Then I can explain some processes to help find
      and remove unnecessary complexity in your apps.
      </div>
    </section>

    <section class="slide">
      <h2>MonoRail
      <span class="small"><a href="http://www.thesimpsons.com/">The
      Simpsons</a></span>
      </h2>
      <ul class="monorail">
        <li class="slide">
          <h4 class="thin">Pre Existing <img src="./images/monorail.jpg" /></h4>
	  <div class="slide-notes">
	    	Yes, we have a MonoRail app. A monolithic multiple years old
	    Rails app with legacy code...
	    <br/><br/>
	    Actually we have more than one, how did we get here. A bit of
	    history.
	    <br/><br/>
	    	The application began as a fork of an existing project to
	quickly validate an idea.
	  </div>
        </li>
        <li class="slide">
          <h4 class="thin">Consumer <img src="./images/monorail2.jpg" /></h4>
          <div class="slide-notes">
	    That grew into a consumer business, which is what most
      people know as LivingSocial today.
	    <br/><br/>
	    That app grew a lot and had many teams working to extend its
      functionality.
	    <br/><br/>
	Eventually it was forked into multiple other applications.
	  </div>
        </li>
	<li class="slide">
	  <table style="margin: 0px auto;"><tr><td>
	    <h4>Admin</h4>
            <img src="./images/monorail3.jpg" />
	  </td><td>
	    <h4>CMS</h4>
            <img src="./images/monorail4.jpg" />
	  </td><td>
	    <h4>CRMS</h4>
            <img src="./images/monorail5.jpg" />
          </td></tr></table>
          <div class="slide-notes">
	   This means all these apps share some of the same
      code, but after each split they have less responsibility.
	    <br/><br/>
	Which code is needed for the smaller slice of responsibilities, what
      can be removed from the parent or child app?
	  </div>
        </li>
      </ul>
    </section>

    <section class="slide">
      <h2>No Cleanup...</h2>
      <img src="./images/monorail6.jpg" />
      <div class="slide-notes">
	If you keep going like this forking apps and growing them for
      years, without ever cleaning up the code.
	<br/><br/>
	You will eventually crash.
	<br/><br/>
	Looking at what the actual code is doing can help can help
      tell you what is necessary.
	<br/><br/>
	While the forking of one MonoRail into two might be uniq to
      our situation, dead code in large apps is not.
	<br/><br/>
	(images are from one of my favroite episodes of the Simpsons)
      </div>
    </section>
      
    <section class="slide">
      <h2>How Dead Code Sticks Around</h2>
      <p>
        <ul>
	  <li>
	  Large teams aren't good at communicating what is no
      longer needed (both Biz & Dev)
	  </li>
      	  <li>A/B tests, never removing a loser</li>
	  <li>One offs that are irrelevant over time</li>
	  <li>Deprecation of old endpoints takes time</li>
	  <li>Refactoring leaves dead code paths behind</li>
      	  <li>Making a 'safe' change & creating new methods
      opposed to altering existing methods with multiple callers</li>
	  <li>There are tests, but it is never used in production</li>
          <li>etc...</li>
	</ul>
      </p>
      <div class="slide-notes">
	Beyond Monorails, dead code can slip into a system in many
      ways.
	<br/><br/>
	I am not really going into all the details, but suffice to
      say. Every system I have worked on grows and at some point has
      unnecessary code tucked away into dark corners.
	<br/><br/>
	Features that don't quite justify their UI complexity,
	<br/>
	pivoting away from some direction,
	<br/>
	either for business or development reasons,
	<br/>
	AB tests, the list goes on and on.
	<br/><br/>
	I am sure many of you have seen this in your own apps.
      </div>
    </section>
	
    <section class="slide">
      <h2>All code is bad</h2>
      <img src="./images/code-horror.gif" />
      <blockquote cite="http://mashable.com/2014/04/30/programming-sucks/">
        <p>
	  Also, the bridge was designed as a suspension bridge, but nobody actually knew how to build a suspension bridge, so they got halfway through it and then just added extra support columns to keep the thing standing
	</p>
        <p><cite>
	<a href="http://mashable.com/2014/04/30/programming-sucks/">
	Peter Welch (Programming Still Sucks)
	</a>
	</cite></p>
      </blockquote>
      <div class="slide-notes">
	There is a pretty hilarious article titled "programming still
      sucks" by Peter Welch, recently making the rounds on the net.
	<br/><br/>
	In it he makes the analogy of a team
      building a bridge, not knowing what they are doing.
	<br/><br/>
	resulting in them building half a suspension and half a support bridge.
	<br/><br/>
	Several things in this article jumped out at me.
	<br/><br/>
	such as the statement, "all code is bad".
	<br/><br/>
	Which obviously not entirely true, must mean...
      </div>
    </section>

    <section class="slide">
      <h2>
	Less Code Is Better
      </h2>
      <ul>
	  <li>is easier to reason about</li>
	  <li>is easier to upgrade (Rails, Ruby, and Gem versions)</li>
	  <li>is easier to refactor</li>
	  <li>is easier to adapt to new requirements</li>
	  <li>means there are fewer and faster tests</li>
      </ul>
      <div class="slide-notes">
      ...Less code is better.
	<br/><br/>
	Obviously if code is doing work for your business it has some value,
      but I don't think I have to spend much time time explaining why having less code
      & simpler systems is better.
	<br/><br/>
	Less Code for many reasons makes it easier you and your team to focus on making
      important changes.
      </div>
    </section>

    <section class="slide">
      <h2>
	Solution: Clean Up Dead Code
      </h2>
      <ul>
	  <li>If "All Code is Bad"</li>
	  <li>Less Code is Better</li>
	  <li>Keep Only the Code Needed, No More</li>
      </ul>
      <div class="slide-notes">
	So if the problem is all code is bad and less code is better, the
      solution is..
	<br/>
	clean up unused code.
	<br/>
	Keeping only the code needed.
	<br/><br/>
	We can make our projects better by only working on what is
      providing value.
	<br/>
	Code that is actively in use by our business
      and users.
	<br/><br/>
	Sounds good, let's delete all the code...
	<br/><br/>
	Or some of it, which code...
      </div>
    </section>

    <section class="slide">
      <h2>All code is bad</h2>
      <img src="./images/code-horror.gif" />
      <blockquote cite="http://mashable.com/2014/04/30/programming-sucks/">
        <p>
	  They left the suspension cables because they're still sort
      of holding up parts of the bridge. Nobody knows which parts, but
      everybody's pretty sure they're important parts.
	</p>
        <p><cite>
	<a href="http://mashable.com/2014/04/30/programming-sucks/">
	Peter Welch (Programming Still Sucks)
	</a>
	</cite></p>
      </blockquote>
      <div class="slide-notes">
	back to the bridge ananlogy in the article
	<br/><br/>
	 something else struck me...
	<br/><br/>
	"They left the suspension cables because they're still sort
      of holding up parts of the bridge."
	<br/><br/>
	and now for the line that really stood out
      </div>
    </section>

    <section class="slide">
      <h2>How to know: Production Code Analysis</h2>
      <blockquote cite="http://mashable.com/2014/04/30/programming-sucks/">
        <p>
	  Nobody knows which parts, but everybody's pretty sure they're important parts.
	</p>
        <p><cite>
	<a href="http://mashable.com/2014/04/30/programming-sucks/">
	Peter Welch (Programming Still Sucks)
	</a>
	</cite></p>
      </blockquote>
      <div class="slide-notes">
	"Nobody knows which parts, but everybody's pretty sure they're important parts."
	<br/><br/>
	Hmmm Really?
	Nobody knows which parts?
	<br/><br/>
	We don't have to settle for guessing, we can solve this
      problem...<br/><br/>
	We can use data.
	<br/><br/>
	We can use code and analytics.
      </div>
    </section>

    <section class="slide">
      <h2>Analyzing Production Code</h2>
      <p>
        <ul>
      	  <li>Use <a href="http://newrelic.com">NewRelic</a>,
	  <a href="https://www.skylight.io/">skylight.io</a>,
	  or <a href="http://info.appneta.com/watrial.html?product=traceview">Appneta Traceview (formerly Tracelytics)</a></li>
	  <li>Custom Stats Instrumentation</li>
	  <li>Use Logs</li>
	  <li>Production Code Coverage</li>
        </ul>
      </p>
      <div class="slide-notes">
	Hopefully that explains a bit about how a team can end up in a
      place where they need data to help them know what is going on
	with their systems.
	<br/><br/>
	I am going to go through some examples of processes we have
      used to find unused code. From very simple methods, to more
      complicated processes.
	<br/><br/>
	We will talk about 3rd party tools<br/>
	Cumstom Stats<br/>
	Using Logs<br/>
	and Prodcution Code Coverage
	<br/><br/>
	Also, note if you run `rake stats` on a
      Rail app and have less than 3-5K lines of code.
	<br/><br/>
	You can probably just reason about the code in your head.
	<br/><br/>
	and these tools might seem like overkill.
	<br/><br/>
	We had apps pushing 80K lines of app code
	<br/><br/>
	excluding the view layer, javascript, and CSS.
      </div>
    </section>

    <section class="slide">
	<h2>Street Cred</h2>
	<img src="./images/deals_loc.png" />
	<p>(grown up marketing speak: "street cred" => "social
	proof")</p>
      <div class="slide-notes">
	These aren't just unproven ideas, these are processes we
	have been able to put into practice.
	<br/><br/>
	Here is my history on one
	of our Monorails apps.
	<br/><br/>
	I am pretty proud to have removed
	nearly 2 lines of code for every one added, while delivery
	additional functionality and faster performance.
      </div>
    </section>

    <section class="slide">
	<h2>Team Effort</h2>
        <h3>My diff over last 2 years</h3>
	<pre>+20973, -47034</pre>
        <h3>Team diff over last 2 years</h3>
	<pre>+197326, -215514</pre>
        <div class="slide-notes">
	  Also, wanted to point out getting code bases into shape. Is
	really a team effort.
	  <br/><br/>
	  You can see my contributions over the last 2 years are
	dwarfed by the teams efforts
	  <br/><br/>
	  As a team we celebrate our code improvements.
	  <br/><br/>
	  Pointing out and cheering on particularly good commits, faster tests,
	code deletion.
	  <br/><br/>
	  Linking to little victories in campfire all the way.
	</div>
    </section>

    <section class="slide">
	<h2>Git Spelunking</h2>
	<pre>[~/projects/deals]git log --numstat --pretty="%H" --author="dan.mayer" --since="2 years ago" app | awk 'NF==3 {plus+=$1; minus+=$2} END {printf("+%d, -%d\n", plus, minus)}'</pre>
        <pre>[~/projects/deals] git log --numstat --pretty="%H" --since="2 years ago" app | awk 'NF==3 {plus+=$1; minus+=$2} END {printf("+%d, -%d\n", plus, minus)}'</pre>
	<div class="slide-notes">
	  If you want to grab some of your own stats, I wanted to
	share a fun git trick to pull up stats for an author and the team.
	</div>
    </section>

    <section class="slide">
      <h2>Problem: Unused Actions</h2>
      
      <div class="slide-notes">
	To find large sections of code no longer in use.
	<br/><br/>
	Let's start by finding actions and routes that are out of use.
	<br/><br/>
	This is one of the easiest ways to find unnecessary code.
	<br/><br/>
	It also can be the most rewarding by removing the top level
	action
	<br/><br/>
	then following through to remove associated helpers, views,
	and occasionally models. 
      </div>
    </section>
	
    <section class="slide">
      <h2>Using 3rd Party tool (NewRelic)</h2>
      <p>Easiest way, look transactions over last 7 days: (note won't
      help with specific formats or never hit endpoints)</p>
      <img src="./images/NR_usage.png" />
      <div class="slide-notes">
	One of the easiest ways to gain insight into what code is
      being used in production is 3rd party
      performance monitoring tools.
	<br/><br/>
	There are a number of popular Ruby performance monitoring
      services. Each allow you to hook into their service sending some
      data to help you monitor and find performance issues.
	<br/></br>
	In this case NewRelic but Skylight.io & Traceview can get you the same data. 
	<br/><br/>
      In the NewRelic transaction view you can sort transactions broken down by controller
      route by usage.
	<br/><br/>
	Anything with 1 view in the last seven days likely isn't pulling its
      weight. It might be worth discussing the cost of those features
      with the team.
	<br/><br/>
	Some of them you may be able to cut.
	<br/><br/>
	A problem with this view, is that it doesn't show which actions received 0 requests.
      </div>
    </section>

    <section class="slide">
      <h2>Using 3rd Party tool (NewRelic)</h2>
      <p>LS made a gem to help,
        <a href="https://github.com/livingsocial/newrelic_route_check">newrelic_route_check</a>
      compare NR reports to Rails routes.</br>
	download the `controller_summary.csv`</p>
      <img src="./images/NR_download.png" />
      <p>run `bundle exec rake newrelic:compare_with_routes`</p>
      <pre>found 335 uniq new relic controller action hits
found 562 uniq Rails routes controller action pairs
exists in new relic, but not in routes: 0
never accessed in new relic stats: ***
Pipeline::DealsController#show
Pipeline::EmailTemplatesController#show
SubscribeButtonController#dropdown_for_deal
...
AuthorizationRulesController#graph
AuthorizationRulesController#change</pre>
      <div class="slide-notes">
        I created a gem to make this easy to check. You can download
      the CSV of NR transactions
	<br/><br/>
	and it can compare it to your Rails routes.
	<br/><br/>
	Finding any routes you have which are never hit.
	<br/><br/>
	The gem works by loading the routes into memory and comparing
      thme with the downloaded data.
	<br/><br/>
	Running this on old production apps always seems to find some long
      forgotten routes.
      </div>
    </section>

    <section class="slide">
      <h2>Stats Instrumentation</h2>
      <p>
        <ul>
	  <li>Actions</li>
      	  <li>Background Events</li>
	  <li>Mailers</li>
	  <li>Views</li>
	  <li>Translations</li>
	  <li>One Off Trackers</li>
	  <li>Two Methods</li>
        </ul>
      </p>
      <div class="slide-notes">
	Moving away from 3rd party tools
	<br/><br/>
	Let's look at Custom Stats
	<br/><br/>
        Custom Stats instrumentation is very flexible. We are going to
      look at a number of techniques to gain insight into what your
      application is actually doing in production.
	<br/><br/>
	We will be looking at (read the list).
      </div>
    </section>

    <section class="slide">
      <h2>Stats Instrumentation: Tools</h2>
      <p>
        <ul>
	  <li><a href="https://github.com/graphite-project/graphite-web">Graphite</a></li>
      	  <li><a href="https://github.com/etsy/statsd">StatsD</a>
	  thanks <a href="http://codeascraft.com/category/engineering/">Etsy</a></li>
          <li><a href="https://github.com/antirez/redis">Redis</a></li>
	</ul>
	<pre><code>#shared code for examples
STATSD= Statsd.new('stat.my.us', PORT).tap{|sd| sd.namespace = 'app_name'}

REDIS = Redis::Namespace.new(:app_name, :redis => Redis.new)
        </code></pre>
      </p>
      <div class="slide-notes">
	To gather those stats we often rely on the same small set of
        tools.
	<br/><br/>
	Which I wanted to quickly mention.
	<br/><br/>
	We use graphite via StatsD
	<br/><br/>
       I wanted to give a shout out to Etsy here, as we rely heavily
        on their tools
	<br/><br/>
	They have shared in great detail how they also use metrics to gain insights.
	<br/><br/>
	StatsD is also extremely performant and while it can be lossy,
      we haven't ever run into performance issues while adding many metrics.
	<br/><br/>
	Below you see some shared constants that will appear in
      several of the examples.
	<br/><br/>
	Internally we have wrappers around our Redis and StatsD usage to deal with things like app name-spacing, common error handling, configurations, etc.
	<br/><br/>
	In the examples I am just using Redis and StatsD directly.
      </div>
    </section>

    <section class="slide">
      <h2>Problem: Unused Actions</h2>
      
      <div class="slide-notes">
	We already discussed how finding unused actions be one of the
	most valuable things to clean up.
	<br/><br/>
	Earlier we solved this using 3rd party performance tools, but
	it is easy to solve with some custom stats. 
      </div>
    </section>
      
    <section class="slide">
      <h2>No NewRelic, No Problem</h2>
      <p>thanks <a href="https://twitter.com/jwhitmire">Jeff
    Whitmire</a></p>
      <pre><code>class ApplicationController < ActionController::Base
  before_filter :track_controller_traffic
  around_filter :track_controller_timing

  def endpoint_name
    "#{params['controller'].gsub('/','.')}.#{params['action']}"
  end

  def track_controller_traffic
    STATSD.increment "traffic.total"
    STATSD.increment "traffic.#{endpoint_name}"
  end

  def track_controller_timing
    STATSD.time("timing.#{endpoint_name}") do
      yield
    end
  end
</code></pre>
      <div class="slide-notes">
	If you don't pay for any of the performance tools this can get
    you some useful basic information.
	<br/><br/>
	Obviously 3rd party performance monitors give you a
    lot more details than this, but this level of data can still be very useful
	<br/><br/>
	We have a couple of ways we have added tracking on endpoints
      and timing in Rails. I think the simplest and cleanest example
      was done by <a href="https://twitter.com/jwhitmire">Jeff
    Whitmire</a>.<br/><br/>
	The code hear just hooks into ApplicationController
	<br/><br/>
	Using a simple before filter to increment each endpoint
	<br/<br/>
	and using an around filter to record basic timing information
    for each endpoint.
	<br/><br/>
	Comparing your routes to traffic can find no longer used actions.
      </div>
    </section>
      
    <section class="slide">
      <h2>Problem: Background Events</h2>
      <p>All events being triggered?</p>
      <div class="slide-notes">
	If you run a sizable Rails app you likely run background
	jobs.
	<br/><br/>
	Some jobs will come and go over time. It is pretty easy to
  remove code that queues a job, while leaving around the job code and
	related methods.
      </div>
    </section>
      
    <section class="slide">
      <h2>Background Events</h2>
      <pre><code># Example for Resque background jobs
def before_perform(*args)
  STATSD.increment "resque.processed.#{get_event_name}"
end

def after_perform(*args)
  STATSD.increment "resque.completed.#{get_event_name}"
end</code></pre>
      <div class="slide-notes">
	 It is easy to instrument how often a event is processed.
	<br/><br/>
	With a bit more work you can record execution time around jobs or
	success/failures on completion.
	<br/><br/>
	This is a simple example assuming hooking into Resque
	<br/><br/>
	but is pretty similar for all queueing frameworks.
      </div>
    </section>

    <section class="slide">
      <h2>Problem: Mailers</h2>
      <p>Are you still sending all your mailers?</p>
      <div class="slide-notes">
	Mailers like background jobs can come and go.
	<br/><br/>
	Stating every mailer as it is sent lets you know when a mailer is no longer needed.
	<br/><br/>
	Alternatively it lets you know your most popular mailers which
      might be worth spending more time improving.
      </div>
    </section>

    <section class="slide">
      <h2>Mailers</h2>
      <pre><code># Example for ActionMailer
class BaseMailer < ActionMailer::Base
  def initialize(method_name=nil, *parameters)
    STATSD.increment "mailers.base_mailer.#{method_name}" if method_name
    #...
    super(method_name, *parameters)
  end
end</code></pre>
     <div class="slide-notes">
       This example hooks into ActionMailer::Base to record stats on
      every mailer sent.
       <br/><br/>
       Like all the other stats you can check graphite to see if a
      mailer is out of use before working on the code.
       <br/><br/>
       We were able to remove a number of mailers like this opposed to
      spending the time fixing them when upgrading Rails.
      </div>
    </section>

    <section class="slide">
      <h2>Problem: Views</h2>
      <p>which views are ever rendered: partials, templates, layouts,
      for each format?</p>
      <div class="slide-notes">
	The view layer more than anywhere else can quickly get messy
	and hard to follow.
	<br/><br/>
	Templates inside layouts, with partials inside partials... Oh My.
	<br/><br/>
	Often a new view gets AB tested and the old one isn't removed.
	<br/><br/>
	Devs aren't sure if the partial is used anywhere else. So they
      copy it and make a new one opposed to changing the shared partial.
	<br/><br/>
	Views also bloat out your helpers over time leaving many view
      specific helpers spread through out the code.
      </div>
    </section>
      
    <section class="slide">
      <h2>Views Rendered</h2>
      <pre><code>subscriptions =
      render_partial.action_view|render_template.action_view
  ActiveSupport::Notifications.subscribe /subscriptions/ do |name, start, finish, id, payload| 
  RenderTracker.track_template(name, start, finish, id, payload) unless name.include?('!') 
end

class RenderTracker
  def self.track_template(name, start, finish, id, payload)
    if file = payload[:identifier]
      STATSD.increment "views.#{file}"
    end
    if layout = payload[:layout]
      Rails.logger.info "[RenderTracker] layout: #{layout}"
    end
  end
end</code></pre>
     <div class="slide-notes">
       ActiveSupport notifications makes it is easy to stats every view file as it is
  rendered.
       <br/><br/>
       In this example we subscribe to<br/>
       render_partial.action_view and<br/>
       render_template.action_view
       <br/><br/>
       This shows how you can either stat or log via the tracking
  method.
       <br/><br/>
       When working on a view file you can now check what kind traffic
  volume the change will effect.
       <br/><br/>
       Or if the view file you were about to refactor, upgrade, and
  fix is out of use.
     </div>
    </section>

    <section class="slide">
      <h2>Views Rendered (with Flatfoot)</h2>
      <p>We made a gem for Rails 3 and up to help: <a href="https://github.com/livingsocial/flatfoot">Flatfoot</a>
      <pre><code>FLATFOOT = Flatfoot::Tracker.new(REDIS)

ActiveSupport::Notifications.subscribe /render_partial.action_view|render_template.action_view/ do |name, start, finish, id, payload|
  FLATFOOT.track_views(name, start, finish, id, payload) unless name.include?('!') 
end

FLATFOOT.used_views
=> ["app/views/home/index.html.erb",...

FLATFOOT.unused_views
=> ["app/views/something/_old_partial.html.erb",...</code></pre>
      <div class="slide-notes">
	The view tracking pattern is simple and I wanted to reuse it
	a few places.
	<br/><br/>
	So we made a gem called Flatfoot to quickly hook it
	up into Rails apps.
	<br/><br/>
	You can see flatfoot still uses notifications subscriptions
	and stores view data in a redis set.
	<br/><br/>
	It provides some helpers to output unused
	views by comparing the view renderings with the files on disk.
	<br/><br/>
	Making it super simple to dig into view
	layer cleanup.
	<br/><br/>
	Often the biggest wins when removing view files are associated
	helpers, Javascript, and CSS.
      </div>
    </section>

    <section class="slide">
      <h2>ActiveSupport::Notifications Oddity</h2>
      <pre><code>###
        # Annoyingly while you get full path for templates
        # templates with file extensions
        # layouts without
        # http://edgeguides.rubyonrails.org/active_support_instrumentation.html#render_partial-action_view
        ###
        if layout_file = payload[:layout]
          unless logged_views.include?(layout_file)
            logged_views << layout_file
            store.sadd(tracker_key, layout_file)
          end
        end</code></pre>

      <div class="slide-notes">
	#note cut this slide if short on time
	I did want to briefly mention a little ActiveSupport oddity I
	found.
	<br/><br/>
	ActiveSupport violated the principle of
	least surprise I felt as I was  working on this.
	<br/><br/>
	Template files in the notifications include the full pathname and file
	extensions.
	<br/><br/>
	For layout files it does not.
	<br/><br/>
	It tripped me up a bit so I figured
	I would mention it. Perhaps someone here can later tell me why.
	<br/><br/>
	Flatfoot has some methods to help track layouts without extensions.
      </div>
    </section>

    <section class="slide">
      <h2>Problem: Translations Usage</h2>
      <p>How many translation keys are you
      loading in memory & never using?
      </p>
      <div class="slide-notes">
	Another piece of an application that can easily become a out
	of sync is translation keys.
	<br/><br/>
	Over time, it is hard to know which
	translations are still in use.
	<br/><br/>
	Often when changing features and removing old code
      translations are left behind.
	<br/><br/>
	Translation keys
	end up causing a sizable memory bloat for production rails
	processes.
	<br/><br/>
	As apps load all translations and keep them available in memory.
      </div>
    </section>
      
    <section class="slide">
      <h2>Translations Usage</h2>
      <p>We made a gem for that <a href="https://twitter.com/the_chrismo">@the_chrismo (Chris Morris)</a> built: <a href="https://github.com/livingsocial/humperdink">Humperdink</a>
      <pre><code>class KeyTracker
  def initialize(REDIS, key)
    redis_set = Humperdink::RedisDirtySet.new(:redis => redis, :key => key, :max_dirty_items => 9)
    @tracker = Humperdink::Tracker.new(redis_set, :enabled => true)
  end

  def on_translate(locale, key, options = {})
    begin
      if @tracker.tracker_enabled
        requested_key = normalize_requested_key(key, options)
        @tracker.track(requested_key)
      end
    rescue => e
      @tracker.shutdown(e)
    end
  end
...</code></pre>
      <div class="slide-notes">
	Chris Morris built Humperdink which has a
    number of uses, but is particularly well suited to help track down
    no longer used translation keys.
	<br/><br/>
	The code to set this up is too large to fully display here
	<br/><br/>
	but it makes it easy to find unused keys and is optimized for
    performance.
	<br/><br/>
	Check out the gem for more details on how
    to track translations, but this slide shows a bit of the basics.
      </div>
    </section>

    <section class="slide">
      <h2>Problem: Complex Code Paths</h2>
      <p>Reading the code, unsure where / if it is called?</p>
      <div class="slide-notes">
	One problem with tracking only controllers actions, is that
      the often serve multiple formats and request paths.
	<br/><br/>
	Also, frequently in scary dark corners of models, helpers, and
      libs folders
	<br/>
	it is hard to be sure if something is entirely out
      of use.
	<br/><br/>
	For that,
      one off trackers can be useful.
	<br/><br/>
	Tracking format specific
      endpoints, conditional paths, the ever growing case statement
	<br/><br/>
	Really to quickly see the frequency of use of any piece of code.
	<br/><br/>
      </div>
    </section>
      
    <section class="slide">
      <h2>One Off Trackers</h2>
      <pre><code># Example Tracking a code path
class HomeController < ApplicationController
  def show
    if request.xhr?
       #some weird logic
       STATSD.increment "deprecated.home_controller.show.xhr"
     end
    respond_to do |format|
        STATSD.increment "deprecated.home.show.#{format}"
        format.html { #... }
        format.json { #... }
        format.mobile { #... }
    end
  end
end</code></pre>
      <div class="slide-notes">
	We use the deprecated namespace in
      our apps to track helper methods, models, views. It
      also provides a quick way to jump into code cleanup. Grep the
      code for deprecated stats, check graphite and safely remove
      code no longer in use.
      </div>
    </section>

    <section class="slide">
      <h2>Problem: Two Methods</h2>
      <p>Which is best, which to keep?
      <br/><br/>
         shout out to <a
      href="https://twitter.com/ubermajestix">@ubermajestix (Tyler
      Montgomery)</a> for showing me the next trick</a>
      </p>
      <div class="slide-notes">
	This isn't actually related to finding unused code, but I like
	this trick so much I wanted to share it.
	<br/><br/>
	Shout out to Tyler Montgomery, who checked this great idea
  into our git one day.
	<br/><br/>
	One off trackers, aren't only useful for finding unused
  code. It can be a great way to launch performance enhancements.
	<br/><br/>
	If you currently have two existing solutions and are decided
      while refactoring which to use, you can take the guess work out
      by measure real world usage.
      </div>
    </section>
      
    <section class="slide">
      <h2>Prod Performance Checks</h2>
      <pre><code>
def example_html_stripping_method
  strip_method = rand(2)&1 == 0 ? 'nokogiri' : 'strip_tags'
  desc = STATSD.time("application_helper.example_html_stripping_method.#{strip_method}") do
    if strip_method == 'strip_tags'
      strip_tags(desc_raw).gsub(/^\s+/,'').gsub(/\s+$/,'')
    else
      Nokogiri::HTML.parse(desc_raw).text.strip
    end
  end
  #...
end</code></pre>
      <div class="slide-notes">
	To gather data on the performance of two implementations with
  production data sets. Simply split
  the code between old and new while sending the timing info to
  StatsD. Gather performance information against actual production
  usage and data, to determine the best algorithm and have a good idea
  of how much better it actually is.
      </div>
    </section>

    <section class="slide">
      <h2>Logs</h2>
      <p>
        <img src="images/logallthethings.png" />
        <span class="img-src">-
	  <a href="http://icanhas.cheezburger.com/">icanhas.cheezburger.com</a>
	</span>
      </p>
      <div class="slide-notes">
	That covers various custom stats so let's talk a little bit
      about logs.
	<br/><br/>
	 Your application logs are a gold mine of information just waiting
      to help you out.
	<br/><br/>
	When you have multiple applications and you are
      trying to refactor or remove old endpoints knowing, which
      clients and versions are using the application can be critical.
	<br/><br/>
      Again if you don't have NR or 3rd party
      performance tools. You can get great rollups of performance for
      controllers and actions with Kibana, Splunk, or other log
      querying tools.
      </div>
    </section>
      
    <section class="slide">
      <h2>Logs</h2>
      <p>
        <ul>
	  <li>Logs need to be searchable, real time is best.
	  (ElasticSearch/Kibana, Splunk, Hadoop)</li>
	  <li>If you have multiple apps that communicate they should
      be in the same system.</li>
	  <li>All your logs should be in one place 
	  (cron, Nginx access/error, background jobs, rails logs)</li>
          <li>Try to standardize log format: important keys / variables
      across systems</li>
        </ul>
      </p>
      <div class="slide-notes">
	To get the most from your logs it takes a bit of work to get
      them into shape.
	<br/><br/>
	You need a near real time log query tool.
	<br/><br/>
	Try to get all your apps logging to the same query tool.
	<br/><br/>
	Apps with multiple with logs like nginx, cron, app, and
      background jobs like wise need to all be sent to the same tool.
	<br/><br/>
	You can implement render_tracking, translation_key tracking,
      and most of the other mentioned systems just by logging data in
      query-able formats to your logs and crafting the correct queries.
	<br/><br/>
	Logs can go deep when you are digging into specific problems like
      debugging exceptions or finding the last few callers while
      deprecating endpoints.
      </div>
    </section>


    <section class="slide">
      <h2>Log Queries</h2>
      <pre># most common format (HTML, JSON) for controller/action
source="*app/*" status=200 |
 top format by controller action

# endpoints with more 406 Not acceptable than 200s
source="*app/*" |
 stats count(eval(status=406)) as UNAUTH,
 count(eval(status=200)) as SUCC
 by controller action | where UNAUTH > SUCC

# endpoints with more redirects than 200s
source="*app/*" |
 stats count(eval(status=301 OR status=302)) as REDIRECT,
 count(eval(status=200)) as SUCC
 by controller action |
 where REDIRECT > SUCC

# find all requests by a given user
source="*app/*" user_id=XXX
      </pre>
      <div class="slide-notes">
	Here are some of the examples of the kinds of queries you can
	craft once you have well formatted logs.
	<br/><br/>
	Most common format per action controller pair
	<br/><br/>
	Endpoints with more 406 Not acceptable than status 200
	success, this often means old clients which are no longer
	valid are never successfully getting to an endpoint. Perhaps
	it can be removed
	<br/><br/>
	Which endpoint redirects more than returns 200
	<br/><br/>
	View all requests by a given user
	<br/><br/>
	I just wanted to share a few examples of questions you can
	answer with your logs.
      </div>
    </section>
      
    <section class="slide">
      <h2>Logs: Deprecation with caller trace</h2>
      <p>
	<pre><code>clean_trace = Rails.backtrace_cleaner.clean(backtrace).join(',')
Rails.logger.info "deprecated=true trace: #{clean_trace}"</code></pre>
      </p>
      <div class="slide-notes">
	If you are trying to discover how the code reaches a path you never
      expect or intend to be executed anymore.
	<br/><br/>
	Tracking that down can be complicated. Detailed logs can help.
	<br/><br/>
	You can log the caller inside a
      method to figure out the call path that reached there.
	<br/><br/>
	These deprecation log lines will let you also discover the initial entry
	point and parameters into your application, if you log
      request_id, which I will mention shortly.
      </div>
    </section>

    <section class="slide">
      <p>this idea was introduced into our codebase by
      <a href="http://www.twitter.com/geeksam">Sam Livingston-Gray</a></p>
	<pre><code>def deprecation_trace(backtrace = caller)
    log_backtrace(backtrace)
    stat_name = stat_name_line(backtrace.first)
    STATSD.increment stat_name
  end
  def log_backtrace(backtrace)
    #...
  end	
  TRACE_SUBS = [
    [ File.expand_path(Rails.root.to_s)  , ''],
    [ /:in `(.*)'/, '#\1' ],
    [ '.rb'       , ''    ],
    [ /:\d+/      , ''    ],
  ]
  def stat_name_line(trace_line)
    t_line = TRACE_SUBS.inject(trace_line){ |ln, gsubs|
    ln.gsub(*gsubs) }
    components = t_line.split(/\W+/).reject(&:blank?).map(&:underscore)
    components = %w[ deprecated ] + components
    components.join('.')
  end</code></pre>
      <div class="slide-notes">
	Combine the deprecation logging with a good idea from <a
    href="http://www.twitter.com/geeksam">Sam Livingston-Gray</a>,
    which automatically builds the deprecation stat based on the
    caller.
	<br/><br/>
	You end up with a really useful deprecation_trace helper method
    you can use while investigating code to remove.
	<br/><br/>
	This code is a bit to complicated to fit on the slide but it
      basically extracts the class and method name to build a well
      formatted deprecation namespace.
	<br/><br/>
	Making it easy to find code from the stat name.
      </div>
    </section>

    <section class="slide">
      <h2>Logs: Better with Imprint</h2>
      <p>Make your logs better with  
	<a href="https://github.com/livingsocial/imprint">Imprint</a>
	 <ul>
	   <li>Request tracing in logs:<br/>
	    All Rails.logger calls during a request tagged with a trace_id</li>
	   <li>Exceptions include trace_id so you can fetch all logs
      related to a request that caused an exception</li>
           <li>Background Jobs failures include the trace_id to find
      the request that queued the job</li>
           <li>Cross app tracing, have client gems pass a header, and
      back end APIs will include the same trace_id as the initial
      front end request</li>
	 </ul>
      </p>
       <div class="slide-notes">
	 One place I turn to logs is to know what is happening on a
      the system between applications or background queues.
	 <br/><br/>
	 Logs can be particularly useful for this level of
      information, Imprint helps make your logs easy to trace across
      apps, jobs, and exceptions.
	 <br/><br/>
	 Imprint builds on ideas from Twitter. Twitter created ZipKin,
      but most of the tooling is in the Scala world. REcent versions
      of Rails also
      provided a request_id which IMPRINT can use.
	 <br/><br/>
	 Imprint makes it
      easy to capture a request trace and help propagate it through
      multiple systems. The gem helps simplify the process to integrate it into
      your tools.
	 <br/><br/>
	 We use imprint in our base internal api-client. This means
       all inter-app service calls will pass the current requests
       trace_id as a header to the server. The receiving api service
      then uses imprint to set the existing trace_id for its logging.
	 <br/><br/>
	 By logging request_id's, and placing that ID in the header,
	 you get a powerful debugging tool.
	 <br/><br/>
	 all your exceptions should now be able to link you back
	 to the original logs related to the request. Similarly failed
      background jobs, logs can be found, and even traced to the
      initial request that queued the background job.
       </div>
    </section>

    <!--
    <section class="slide">
      <h2>Logs: Imprint Example</h2>
      <p>
       TODO
      </p>
       <div class="slide-notes">
	#TODO imprint usage example!
       </div>
    </section>
    -->

    <section class="slide">
      <h2>Production Code Coverage</h2>
      <div class="slide-notes">
	Most of the mention stat monitors focus on a particular piece of the
	puzzle.
	<br/><br/>
	Stats takes effort to setup ahead of time and then time to collect and analyze the data.
	<br/><br/>
	It seemed like a pattern could be
      abstracted, which would be more generally useful.
	<br/><br/>
	Really I wanted to know how often a given line of code was being run in production.
	<br/><br/>
	Ruby VM tooling isn't quite there to let us do this, but it keeps getting
      better.
	<br/><br/>
	while Ruby's StdLib Coverage make this easy to do for tests, it has
      some bugs that prevent it being used for production.
	<br/><br/>
	Ruby 2.1 introduced a sampling profiler, which I am
      investigating for real time code coverage without larger
      performance impacts.
	<br/><br/>
	Although being on Ruby 2.1 would limit the usefulness for
      large old monoRail apps.
	<br/><br/>
	To get support in Ruby 1.9 I built a solution with set_trace_func
      </div>
    </section>
       
    <section class="slide">
      <h2>Production Code Coverage: Coverband</h2>
      <p>
        <ul>
	  <li>Based on `set_trace_func`</li>
      	  <li>It would be better to be based on `Coverage` but there is a bug in Ruby</li>
	  <li>(Looking for C help, so I can try to patch Ruby, anyone
      got those skills?)</li>
	  <li>Performance hit reduced by sampling</li>
	  <li>
	    <a href="https://github.com/danmayer/coverband">github.com/danmayer/coverband</a>
	  </li>
        </ul>
      </p>
      <div class="slide-notes">
	While useful being based on set_trace_func,
	can be slow.
	<br/><br/>
	To deal with that I allow for request sampling.
	<br/><br/>
	We are using it in production on large Rails apps with a low
      sample rate and collecting some pretty good data.
	<br/><br/>
	Unfortunately, the performance hit is pretty large for big
      applications.
	<br/>
	I am running this on Monorail size apps with about
      1% of requests being sampled. While I can run 60-90% of requests
      small Sinatra apps without noticing much of a performance
      impact.
	<br/><br/>
	Unfortunately the Std Lib Coverage bug mentioned was causing segfaults
      in Ruby 1.9 and 2.0. While tht was fix and it doesn't segfault in 2.1 it still
      doesn't work correctly when sampling, only reporting data for a
      file once, ignoring usage after that.
	<br/><br/>
	Based on Terance's talk earloer at the conference I am preparing
      a good and reproducable bug report to submit to
      ruby-core.
	<br/><br/>
	Thanks for inspiring me to do more than complain on twitter, Terence.
	<br/><br/>
	Also, I am currently in progress with a native c extension which
	should significantly improve performance. This would allow
	faster data collection still going back to Ruby 1.9
	<br/>br/>
	If anyone has strong C skills and is
      interested in helping out, I am definitely in need of some help
      in this area. 
      </div>
    </section>

    <section class="slide">
      <h2>Production Code Coverage: Coverband</h2>
      <p>
      Example Output:
      <a href="./examples/coverage/index.html" target="blank">churn-site coverage</a>
      </p>
    </section>

    <section class="slide">
      <h2>Production Code Coverage: Coverband</h2>
      <pre><code>baseline = Coverband.parse_baseline
Coverband.configure do |config|
  config.root  = Dir.pwd
  config.redis = REDIS
  config.coverage_baseline = baseline
  config.root_paths = ['/app/']
  config.ignore = ['vendor']
  config.startup_delay = Rails.env.production? ? 15 : 1
  config.percentage = Rails.env.production? ? 10.0 : 95.0
  config.stats = STATSD
  config.verbose = Rails.env.production? ? false : true
  config.logger = Rails.logger
end</code></pre>
      <div class="slide-notes">
	Coverband works as rack middleware. It decides whether to
      sample a request as it comes in. When enabled for a request stores the
      coverage of code run during the entire request and sync it up to Redis
      at the end of the request.
	<br/><br/>
	To configure coverband you can either put this config block
      where necessary of place it in `config/coverband.rb` which it
      gets picked up when you call Coverband.configure.
	<br/><br/>
	`Coverband.parse_baseline` tells Coverband where to find a
      baseline recording of code coverage just from loading the
      application. A lot of Ruby code is run just loading the Rails
      app, and that isn't capture during the request cycle. So we can
      just record that once and merge it in with live coverage data.
	<br/><br/>
	Setting it up, you can see I provide different settings for
      development and production. It makes it easier to test and
      verify in development with a large sample rate.
	<br/><br/>
	A couple settings to note, `config.startup_delay` Rails
      defines a lot of methods dynamically on the first few requests
      so they are ignored because they can run much slower with Coverband.
	<br/><br/>
	percentage is the number of requests that we will sample and
      record with coverband.
	<br/><br/>
	ignore lets you not record section of code you wish to
      skip. Skipping heavy non app code like vendor or lib can also
      help to reduce the performance impact.
      </div>
    </section>

    <section class="slide">
      <h2>Production Code Coverage: Coverband</h2>
      <pre><code>#configure rake
require 'coverband'
Coverband.configure
require 'coverband/tasks'

#setup middleware in `config.ru`
require File.dirname(__FILE__) + '/config/environment'
require 'coverband'
Coverband.configure

use Coverband::Middleware
run ActionController::Dispatcher.new</code></pre>
      <div class="slide-notes">
	After installing the gem and creating a config file. You want
	to include the rake tasks into your `Rakefile` and you want to
	setup the middleware.
	<br/><br/>
	In this example I am setting up the middleware as early as
      possible in the `config.ru`. You can also, just set it up in the
	standard Rails middleware stack.
      </div>
    </section>

    <section class="slide">
      <h2>Production Code Coverage: Coverband</h2>
      <pre><code>config.verbose = 'debug'
coverband file usage:
      ["./app/models/deal_modules.rb", 9],
      ...
      ["./app/models/deal.rb", 20606],
      ["./app/helpers/application_helper.rb", 43150]]

file:
  ./app/helpers/application_helper.rb =>
  [[448, 1], [202, 1],
  ...
  [516, 38577]]</code></pre>
      <div class="slide-notes">
	Coverband can give you interesting information and help you to
      find code hotspots in development mode as well.
	<br/><br/>
	If you enable
      verbose mode in the config, at the end of each request it
  outputs how often a file was accessed.
	<br/><br/>
	If you set verbose mode to 'debug' it will further break down
  the number of times an individual line on a file was called.
	<br/><br/>
	In the example output of the slide you can see application
  helper was hit
	43K times during this request. While like 516 of that file was
  hit 38K times.
	<br/><br/>
	That doesn't always mean there is a problem, but it might be
  worth investigating what is going on there. 
      </div>
    </section>

    <section class="slide">
      <h2>Gems</h2>
        <ul>
	  <li>New Relic Helpers: <br/>
	    <a href="https://github.com/livingsocial/newrelic_route_check">livingsocial/newrelic_route_check</a></li>
	  <li>View Render Tracking: <br/>
	    <a href="https://github.com/livingsocial/flatfoot">livingsocial/flatfoot</a></li>
	  <li>Translation Tracking: <br/>
	    <a href="https://github.com/livingsocial/humperdink">livingsocial/humperdink</a></li>
	  <li>Log Helpers: <br/>
	    <a href="https://github.com/livingsocial/imprint">livingsocial/imprint</a></li>
	  <li>Production Code Coverage: <br/>
	    <a href="https://github.com/danmayer/coverband">danmayer/coverband</a></li>
        </ul>
      <div class="slide-notes">
	Here is a list of the gems, I mentioned during the talk.
	<br/><br/>
	These are all open source released by various LivingSocial engineers.
      </div>
    </section>

    <section class="slide">
      <h2>Other Useful Gems</h2>
        <ul>
	  <li>many things from <a href="https://twitter.com/tmm1">Aman Gupta (@tmm1)<a/></li>
	  <ul>
  	    <li>Ruby Profilers
	    <ul>
	      <li>
	       <a href="https://github.com/tmm1/perftools.rb">Perftools.rb</a>
      and related <a
      href="https://github.com/bhb/rack-perftools_profiler">rack
      preftools from @bhb</a> (Ruby < 2.1)</li>
              <li><a
      href="https://github.com/tmm1/stackprof">Stackprof</a> Modern
      Replacement for Perftools.rb (Ruby >= 2.1)</li>
	    </ul>
	    <li><a href="https://github.com/tmm1/rbtrace">rbtrace</a>
      (like strace for Ruby)</li>
            <li><a href="https://github.com/tmm1/rblineprof">rblineprof</a></li>
            <li><a
      href="https://github.com/rack/rack/commit/f791197f501776480a67211afbca0b32c628b2c9">Rack
      Warmup</a> to avoid performance hits on initial requests</li>
	    <li><a href="http://tmm1.net/ruby21-rgengc/">A history of Ruby's GC</a></li>
            <li><a href="https://github.com/tmm1/gctools">gctools</a>
      out of band GC tools optimized for Ruby 2.1</li>
	  </ul>
	  <li><a href="https://twitter.com/srawlins">Sam Rawlins
      (@srawlins)</a> awesome GC work.</li>
	  <ul>
      <li><a
      href="https://github.com/srawlins/allocation_stats">AllocationStats</a>
      GC tooling</li>
      <li><a href="https://github.com/srawlins/rack-allocation_stats">rack-allocation_stats</a> making GC tooling even
      more accessible</li>
      <li><a
      href="http://www.confreaks.com/videos/3272-mwrc-new-ruby-2-1-awesomeness-pro-object-allocation-tracing">Ruby
      2.1 Awesomeness: Pro Object Allocation Tracing</a> (mtnwest ruby
      talk)</li>
          </ul>
	  <li><a
      href="https://github.com/change/method_profiler">MethodProfiler</a>
      from Change.org</li>
          <li><a
      href="https://github.com/simeonwillbanks/busted">busted</a> find
      method cache invalidation by <a href="https://github.com/simeonwillbanks">Simeon Willbanks</a></li>
          <li><a
      href="http://avsej.net/2012/systemtap-and-ruby-20/">Ruby 2.0 and
      Systemtap</a></li>
        </ul>
	
      <div class="slide-notes">
	While I focused on code analysis to understand what a system
	is doing and finding unused code paths. Obviously there are a
	lot of other amazing production code analysis tools. Ruby
	historically hasn't been very good it has been improving.
	We have members of the community that are
	working on making better.
	<br/><br/>
	So I wanted to point out some other gems and tools that can
	either help you understand what is going on with your system
	or with the performance of the code as it runs. Some of these
	tools can be used in production while others are a probably
	best in development only until the tooling gets better.
	<br/><br/>
	Anything by by Aman Gupta is generally awesome. Not only has
      he released amazing gems and tools. He is now on the frontline
      improving the Ruby VM to help it provide valuable runtime data
      back to clients.
	<br/><br/>
	Sam Rawlins has been doing amazing work related to GC tools to
      help you understand what is going on on systems. I recommend his
      MtnWestRuby talk
	<br/><br/>
	change.org has related a interesting MethodProfiler tool.
	<br/><br/>
	Simeon Willbanks has a interesting tool that will collect
      method cache invalidations for Ruby 2.1
	<br/><br/>
	A lot of great work is going on to help give us better
      insights into what is happening with our code on production.
      </div>
    </section>
      
    <section class="slide ls">
      <h1>Thanks</h1>
      <p>
        <ul>
	  <li>
	    <a href="http://mayerdan.com">Dan Mayer</a>
	    <ul>
	      <li>slides: <a href="http://www.mayerdan.com/rubynation-production-code-analysis/">mayerdan.com/rubynation-production-code-analysis/</a></li>
	      <li><a href="http://twitter.com/danmayer">twitter: @danmayer</a></li>
	    </ul>
	  </li>
	  <li><a href="http://livingsocial.com">LivingSocial</a>
      (We're hiring)<br/>
	  </li>
        </ul>
      </p>
      <div class="slide-notes">
	I wanted to say thanks to LivingSocial who lets me work some
      of these tools and sends me around to some conferences. Also, if
      you think any of this is interesting we are hiring.
	<br/><br/>
	Thanks for listening, hope you found some of this useful for
      your applications.
      </div>
    </section>

    <!-- End slides. -->

    <!-- Begin extension snippets. Add or remove as needed. -->
      
    <!-- deck.status snippet -->
    <p class="deck-status" aria-role="status">
      <a href="#" class="deck-prev-link" title="Previous">&#8592;</a> <span class="deck-status-current"></span>
      /
      <span class="deck-status-total"></span> <a href="#" class="deck-next-link" title="Next">&#8594;</a>
    </p>

    <script>
      var notesLoad = function() {
        $.deck('getSlide').find('.slide-notes').toggle('slideup');
      };

    </script>
      
    <p class="deck-notes-pop" aria-role="status">
      <a href="#" onclick="script: notesLoad();" class="deck-notes-pop-link">speaker notes</a>
    </p>

    <!-- deck.goto snippet -->
    <form action="." method="get" class="goto-form">
      <label for="goto-slide">Go to slide:</label>
      <input type="text" name="slidenum" id="goto-slide" list="goto-datalist">
      <datalist id="goto-datalist"></datalist>
      <input type="submit" value="Go">
    </form>

    <!-- End extension snippets. -->
  </div>

<!-- Required JS files. -->
<script src="jquery.min.js"></script>
<script src="core/deck.core.js"></script>
<!-- include the below to do presentation mode locally -->
<script src="core/deck.remote.js"></script>

<!-- Extension JS files. Add or remove as needed. -->
<script src="extensions/menu/deck.menu.js"></script>
<script src="extensions/goto/deck.goto.js"></script>
<script src="extensions/status/deck.status.js"></script>
<script src="extensions/navigation/deck.navigation.js"></script>
<script src="extensions/scale/deck.scale.js"></script>

<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>hljs.initHighlightingOnLoad();</script>
<script>  
  $(function() {
    $.deck('.slide');
  });

  /* quick function to hide speaker notes on slide change*/
   (function($, undefined) {
   var $document = $(document);

   var hideNotes = function(event, from, to) {
     $('.slide-notes').hide();
   };
  $document.bind('deck.change', hideNotes);
  })(jQuery, 'deck');
</script>
</body>
</html>
